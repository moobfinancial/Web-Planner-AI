"use client";

    import { useState, useRef } from 'react';
    import { useSession } from 'next-auth/react';
    import { revalidateDashboardPaths } from '@/app/actions/revalidation';
    import { jsPDF } from 'jspdf';
    import {
      Dialog,
      DialogContent,
      DialogDescription,
      DialogFooter,
      DialogHeader,
      DialogTitle,
      DialogTrigger,
    } from "@/components/ui/dialog";
    import { Button } from "@/components/ui/button";
    import { Loader2, CheckCircle } from 'lucide-react';
    import { toast } from "@/components/ui/use-toast";

    interface PdfExportDialogProps {
      planId: string;
      projectId: string;
      contentRef: Record<string, string>; // Content passed from parent
    }

    export function PdfExportDialog({ planId, projectId, contentRef }: PdfExportDialogProps) {
      // We don't need the session data client-side for this fetch
      // const { data: session } = useSession();
      const [isGenerating, setIsGenerating] = useState(false);
      const [isOpen, setIsOpen] = useState(false);
      const previewRef = useRef<HTMLDivElement>(null);

      const generatePdf = async () => {
        setIsGenerating(true);
        try {
          const doc = new jsPDF();
          let position = 20;

          // Add header
          doc.setFontSize(18);
          doc.text(`Project Plan - ${projectId}`, 14, position);
          position += 15;

          // Iterate through content sections
          for (const [sectionTitle, sectionContent] of Object.entries(contentRef)) {
            doc.setFontSize(14);
            doc.text(sectionTitle, 14, position);
            position += 10;

            doc.setFontSize(12);
            // Ensure sectionContent is treated as string
            const contentString = String(sectionContent || '');
            const splitText = doc.splitTextToSize(contentString, 180);
            splitText.forEach((text: string) => {
              if (position > 280) { // Check if position exceeds page height
                doc.addPage();
                position = 20; // Reset position for new page
              }
              doc.text(text, 14, position);
              position += 7; // Adjust line height spacing
            });

            position += 10; // Add spacing between sections
          }

          // Add footer
          const date = new Date().toLocaleDateString();
          doc.setFontSize(10);
          // Position footer at the bottom margin
          doc.text(`Generated by WebPlanner - ${date}`, 14, doc.internal.pageSize.height - 10);

          doc.save(`webplanner-plan-${planId}.pdf`);

          toast({
            title: "PDF Exported Successfully",
            description: "Your plan has been saved as a PDF file.",
            action: <CheckCircle className="text-green-500" />,
          });

          // Log activity after successful PDF generation
          try {
            // Session is checked server-side by the API route using the cookie
            const response = await fetch(`/api/plans/${planId}/activity`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                // No Authorization header needed; cookie is sent automatically
              },
              body: JSON.stringify({
                activityType: 'PDF_EXPORTED',
                details: `Exported PDF for plan ${planId}`
              })
            });

            if (!response.ok) {
              let errorMessage = 'Activity logging failed';
              try {
                const contentType = response.headers.get('content-type');
                if (contentType?.includes('application/json')) {
                  const errorData = await response.json();
                  errorMessage = errorData.error || errorData.message || errorMessage;
                } else {
                  errorMessage = await response.text() || errorMessage;
                }
              } catch (e) {
                console.error('Error parsing error response:', e);
              }
              toast({
                title: "Activity Tracking Warning",
                description: errorMessage,
                variant: "destructive",
              });
            } else {
               // Revalidate only on successful activity logging
               try {
                 const result = await revalidateDashboardPaths(planId);
                 if (!result.success) {
                   toast({
                     title: "Refresh Warning",
                     description: result.error || "Activity feed might not update immediately",
                     variant: "destructive",
                   });
                 }
               } catch (error) {
                 console.error('Revalidation error:', error);
                 toast({
                   title: "Cache Update Warning",
                   description: "Activity feed might not refresh immediately",
                   variant: "destructive",
                 });
               }
            }
          } catch (error: any) { // Catch specific error type if possible
            console.error('Activity logging or revalidation failed:', error);
            toast({
              title: "Activity/Refresh Error",
              description: error.message || "Failed to log activity or refresh data.",
              variant: "destructive",
            });
          }
        } catch (error: any) { // Catch specific error type if possible
          console.error('PDF generation failed:', error);
          toast({
            title: "Export Failed",
            description: error.message || "Could not generate PDF. Please try again.",
            variant: "destructive",
          });
        } finally {
          setIsGenerating(false);
          setIsOpen(false); // Close dialog after attempt
        }
      };

      return (
        <Dialog open={isOpen} onOpenChange={setIsOpen}>
          <DialogTrigger asChild>
            <Button variant="outline">
              {isGenerating ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
              Export as PDF
            </Button>
          </DialogTrigger>

          <DialogContent className="max-w-4xl h-[90vh] flex flex-col">
            <DialogHeader>
              <DialogTitle>PDF Preview</DialogTitle>
              <DialogDescription>
                Review your plan before exporting. The PDF will include all section content.
              </DialogDescription>
            </DialogHeader>

            {/* Preview Area */}
            <div ref={previewRef} className="flex-grow overflow-auto p-6 space-y-6 bg-white text-black border rounded-md mb-4">
              <div className="text-center mb-8">
                <h1 className="text-2xl font-bold mb-2">Project Plan</h1>
                <p className="text-sm text-gray-500">Plan ID: {planId}</p>
                <p className="text-sm text-gray-500">Project ID: {projectId}</p>
              </div>

              {/* Render content sections for preview */}
              {Object.entries(contentRef).map(([section, content]) => (
                <div key={section} className="mb-6 break-words">
                  <h2 className="text-xl font-semibold mb-2 border-b pb-1">{section}</h2>
                  {/* Ensure content is treated as string and handle potential objects/arrays */}
                  <div className="text-sm whitespace-pre-wrap">{typeof content === 'string' ? content : JSON.stringify(content, null, 2)}</div>
                </div>
              ))}

              <div className="text-center text-xs text-gray-400 mt-8 pt-4 border-t">
                Generated by WebPlanner - {new Date().toLocaleDateString()}
              </div>
            </div>

            <DialogFooter>
              <Button onClick={generatePdf} disabled={isGenerating}>
                {isGenerating ? (
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                ) : null}
                Download PDF
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      );
    }
